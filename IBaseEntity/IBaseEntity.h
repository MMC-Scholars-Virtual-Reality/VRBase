#pragma once

#include "System/Debug.h"
#include "System/Globals.h"

#ifndef VRBASE_INPUT_H
#define VRBASE_INPUT_H

#include "System/EHandle.h"

interface IBaseEntity;
class ABaseController;

extern ABaseController* g_pLeftController;
extern ABaseController* g_pRightController;
extern ABasePawn*       g_pBasePawn;

// Bitfields offset for button inputs.
// These are used by the bitwise math in order to
// mark/unmark which buttons are being pressed.
#define IN_AX      BF(1)
#define IN_BY      BF(2)
#define IN_TRIGGER BF(3)
#define IN_GRIP    BF(4)
#define IN_MENU    BF(5)
#define IN_STICK   BF(6)

// Describes a specific setting of when a given entity is to be triggered by a
// controller. These are generated by entities in order to register themeselves
// with controllers.
struct SEntityInputTriggerRequirement {
    EHANDLE m_ent;         // which entity is to be triggered by this event?
    uint32  m_iButton;     // bitfield - which button are we listening for?
    bool    m_bOnReleased; // is this triggered when the button is released, instead
                           // of pressed?
};

// forward declaration of entity input registration parameters
struct FEntityInputRegistrationParams;

#endif // VRBASE_INPUT_H

#define BF(i)             (1UL << i)
#define FL_NODAMAGE       BF(0) // ignores all damage whatsoever
#define FL_INVINCIBLE     BF(1) // damage events happen, but never actually dies
#define FL_ROUND_PRESERVE BF(2) // round restarts don't respawn this entity
#define FL_ROUND_DESTROY  BF(3) // round restarts destroy this entity
#define FL_IGNORE_USE     BF(4) // entity ignores generic "+Use" functionality
#define FL_INGORE_INPUT                                                             \
    BF(5) // entity ignores all player controller input whatsoever
#define FL_EXTRA   BF(6)
#define FL_EXTRA_2 BF(7)

/**
 *-------------------------------------------------------------------------------------
 * IBaseEntity
 * IBaseEntity is an interface which declares functionality common to all "Base"
 *types and defines some of the most basic functions.
 *-------------------------------------------------------------------------------------
 */
interface IBaseEntity {
public:
    friend class CGlobalVars; // allow CGlobalVars to access s_iEntityCount
    IBaseEntity();
    virtual ~IBaseEntity() {}

    ftime m_tConstructionTime;
    void  RemoveSelfFromLists(); // invalidates EHANDLES but DOES NOT modify static
                                 // counts
    bool        DestroyEntity(); // destroys this Actor
    inline void ReportReady() { s_iReadyEntityCount++; }

    //-------------------------------------------------------------------------------------
    // Entity indexing system
    //-------------------------------------------------------------------------------------

    inline eindex EntIndex() const { return m_iEntIndex; }
    EHANDLE       GetEHandle() const { return EHANDLE(this); }

    // A collection of references to all BaseEntities present in the world
    // at any given moment
    // NOTE: This information cannot be retrieved from a Blueprint since
    // Blueprints cannot read IBaseEntities
    static TArray<IBaseEntity*> s_aBaseEntities;

    // bool whether entities have already been initialized (e.g. PreInits and
    // PostInits called)
    static bool s_bHasAlreadyInitializedBaseEntities;

private:
    eindex m_iEntIndex;

protected:
    void BeginPlay() {
        IBaseEntity::s_aBaseEntities.Add(this);
        if (IBaseEntity::s_bHasAlreadyInitializedBaseEntities) {
            PreInit();
            PostInit();
        }
    }
    void EndPlay(const EEndPlayReason::Type EndPlayReason) {
        IBaseEntity::s_aBaseEntities.Remove(this);
        PreDestroy();
        PostDestroy();
    }

    static int s_iReadyEntityCount;
    static int s_iEntityCount;

    //-------------------------------------------------------------------------------------
    // Initialization system
    //-------------------------------------------------------------------------------------

public:
    virtual void PreInit() {}
    virtual void PostInit();

    virtual void PreDestroy() {}
    virtual void PostDestroy(){};

    //-------------------------------------------------------------------------------------
    // Linkage to vanilla Unreal system
    //-------------------------------------------------------------------------------------
    // This assumes that this is an actor. If not, segmentation faults
    // may occur, or something worse!

public:
    static IBaseEntity* FromActor(AActor * pActor);
    inline IBaseEntity& GetRef() { return *this; }
    inline AActor*      GetActor() const { return m_pSelfAsActor; }

protected:
    AActor* m_pSelfAsActor;

    //-------------------------------------------------------------------------------------
    // Initial transform
    //-------------------------------------------------------------------------------------
protected:
    FTransform m_tInitialTransform;

public:
    FTransform getInitialTransform() { return m_tInitialTransform; };
    FVector    getInitialScale() { return m_tInitialTransform.GetScale3D(); };
    FRotator   getInitialRotation() { return m_tInitialTransform.Rotator(); };
    FVector    getInitialLocation() { return m_tInitialTransform.GetLocation(); };

    //-------------------------------------------------------------------------------------
    // Think System
    //-------------------------------------------------------------------------------------

public:
    typedef void (*BASEPTR)(void*);
    virtual void DefaultThink(); // this think function is always called
    inline void  Think() {
        if (m_pfnThink) m_pfnThink(m_pThinkParam);
    }
    inline void  SetNextThink(ftime time) { m_tNextThink = time; }
    inline ftime GetNextThink() const { return m_tNextThink; }
    inline void  ThinkSet(BASEPTR pProcedure, void* pThinkParam) {
        m_pfnThink    = pProcedure;
        m_pThinkParam = pThinkParam;
    }
    inline void StopThink() {
        m_pfnThink    = NULL;
        m_pThinkParam = NULL;
    }

#define SetThinkEnt(func, ent)                                                      \
    ent->ThinkSet((BASEPTR)(func), reinterpret_cast<void*>(ent))
#define SetThink(func) SetThinkEnt(func, this)

    // TODO deprecate
    static inline bool AllEntitiesReady() {
        return s_iReadyEntityCount == s_iEntityCount;
    }

private:
    BASEPTR m_pfnThink    = nullptr;
    void*   m_pThinkParam = nullptr;
    ftime   m_tNextThink;

    //-------------------------------------------------------------------------------------
    // Flag system
    //-------------------------------------------------------------------------------------
    // compactly stores up to 64 booleans as an unsigned long has 64 bits

public:
    inline ulong GetFlags() const { return m_iFlags; }
    inline bool  HasFlags(ulong flags) const { return (m_iFlags & flags) != 0; }
    inline bool  HasFlagsAll(ulong flags) const {
        return (m_iFlags & flags) == flags;
    }
    inline void AddFlags(ulong flags) { m_iFlags |= flags; }
    inline void RemoveFlags(ulong flags) { m_iFlags &= ~flags; }
    inline void ToggleFlags(ulong flags) { m_iFlags ^= flags; }
    inline void ResetFlags() { m_iFlags = m_iSpawnFlags; }

protected:
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "IBaseEntity")
    ulong m_iSpawnFlags = 0;
    ulong m_iFlags;

    //-------------------------------------------------------------------------------------
    // Generic "use" system
    //-------------------------------------------------------------------------------------

public:
    bool Use(ABaseEntity * pActivator); // returns true on success, false if blocked
    virtual void OnUsed(ABaseEntity * pActivator) {}
    inline bool  IsUseable() const {
        return !HasFlags(FL_IGNORE_USE | FL_INGORE_INPUT);
    }
    virtual bool     IsUseableBy(const ABaseController*) const { return true; }
    inline bool      IsInputEnabled() const { return !HasFlags(FL_INGORE_INPUT); }
    UInputComponent* GetInput();
    void             RegisterInputsToControllers();

    ftime m_tLastTimeUsed;

    // overriden by functions declared in ABaseEntity
    virtual FEntityInputRegistrationParams*
    GetLeftControllerInputRegistrationParams() {
        return NULL;
    }
    virtual FEntityInputRegistrationParams*
    GetRightControllerInputRegistrationParams() {
        return NULL;
    }
};

template <class T> inline T* ExtractArg(void* pParam) {
    return reinterpret_cast<T*>(pParam);
}

// finds a UStaticMesh by path
UStaticMesh* FindMesh(const wchar_t* path);
UStaticMesh* FindMesh(const char* path);
